#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
@Project :Python数据结构和算法 
@File    :1.2 时间复杂度.py
@Author  :Sunshine
@Date    :05/12/2023 12:51 
'''

# 优化1.1 的算法

import time

start = time.time()
# 程序运行的时间不一样， 但是运行的步骤是一样
# 程序运行的步骤 时间频度 T
# 细分:T = 1000 * 1000 * 8  【3. 循环结构， 时间复杂度按照乘法来计算】
#                   [ 1. 计算 1000-a-b
#                     2.  结果赋值给 c
#                     3-5. 计算a**2 b**2 c**2
#                     6. a**2 与 b**2 结果相加
#                     7. 判断 a**2 + b**2 是否与 c**2相等
#                     8. 打印]

# 粗分:T = 1000 * 1000 * 3

# 若把循环改为 2000: 那 t = 2000 * 200 * 3
# 如果说把问题的数据规模设为n,T=n*n*3
# T = 3*n^2
# 当 n 为无穷大时, 时间频度的式子中， 谁的值最大， 那么时间复杂度就是谁
# O(n^2)


''' 时间复杂度的计算规则 '''
# 1. 计算时， 往往只关注时间频度中最高次项， 其他次要项和常数项忽略
# T = 3*n^3 + 2*n^2 + 1000    [忽略常数项 得到 n^3 + n^2]
# O(n^3) [选着最高次项]
for a in range(1001):
    for b in range(1001):
        c = 1000 - a - b
        if a**2 + b**2 == c**2:
            print(f'组合{a}, {b}, {c} 满足条件')

end = time.time()
print('程序执行时间为:', end-start, '秒')

print('------------------------------------------------------------------------------------------------')

# 2.  顺序结构， 时间复杂度按加法来计算
# 让用户输入两个列表，一个列表的长度造n，另一个长度是n，对这两个列表分别求和
# 比较它们的和的大小

# 循环遍历，分别求和，比较大小
# m步, n步 O(m+n)


